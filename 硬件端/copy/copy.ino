 
/*
   采用外接电源单独供电，2 3口作为软串口接PC机作为调试端
   1 0为串口，连接WIFI模块
*/
//引入ESP8266.h头文件，建议使用教程中修改后的文件

#include "SoftwareSerial.h"

//配置ESP8266WIFI设置

#include <U8glib.h>
//在oled屏上显示汉字，字库对于arduino来说太大了，所以还是需要采用取模的方式
const unsigned char PROGMEM ri11[] = {
0x00,0x00,0x20,0x00,0x11,0xF8,0x10,0x08,0x00,0x08,0x00,0x08,0xF0,0x08,0x11,0xF8,
0x11,0x08,0x11,0x00,0x11,0x00,0x11,0x00,0x15,0x02,0x19,0x02,0x10,0xFE,0x00,0x00
};
const unsigned char PROGMEM ri12[] = {
0x08,0x00,0x0B,0xF8,0x12,0x08,0x23,0xF8,0x4A,0x08,0x0B,0xF8,0x10,0x00,0x33,0xFC,
0x50,0x10,0x97,0xFE,0x10,0x10,0x12,0x10,0x11,0x10,0x10,0x10,0x10,0x50,0x10,0x20
};
const unsigned char PROGMEM ri13[] = {
0x02,0x00,0x02,0x00,0x07,0xF0,0x08,0x20,0x38,0x40,0x04,0x80,0x03,0x40,0x0C,0x80,
0x71,0xF8,0x02,0x08,0x0C,0x10,0x32,0x20,0x01,0x40,0x01,0x80,0x0E,0x00,0x70,0x00
};
const unsigned char PROGMEM ri14[] = {
0x02,0x00,0x01,0x00,0x7F,0xFE,0x48,0x22,0x90,0x14,0x00,0x00,0x3F,0xFC,0x00,0x40,
0x10,0x40,0x20,0x40,0x3F,0xFE,0x01,0x40,0x06,0x40,0x18,0x40,0x61,0x40,0x00,0x80
};
const unsigned char PROGMEM ri15[] = {
0x02,0x00,0x02,0x00,0x02,0x00,0x03,0xFC,0x02,0x00,0x02,0x00,0x3F,0xF0,0x20,0x10,
0x20,0x10,0x20,0x10,0x3F,0xF0,0x00,0x00,0x24,0x88,0x22,0x44,0x42,0x44,0x80,0x04
};
const unsigned char PROGMEM ri16[] = {
0x02,0x00,0x01,0x00,0x01,0x00,0xFF,0xFE,0x02,0x00,0x02,0x00,0x05,0x00,0x05,0x08,
0x08,0x90,0x18,0xA0,0x28,0x40,0x48,0x20,0x88,0x10,0x0A,0x08,0x0C,0x06,0x08,0x00
};
const unsigned char PROGMEM ri17[] = {
0x00,0x00,0x3E,0xFC,0x22,0x84,0x22,0x84,0x22,0x94,0x3E,0x88,0x22,0x80,0x22,0xFC,
0x22,0xA4,0x3E,0xA4,0x22,0xA8,0x22,0xA8,0x22,0x90,0x42,0xA8,0x4A,0xC4,0x84,0x82
};
const unsigned char PROGMEM ri21[] = {
0x00,0x00,0x20,0x00,0x11,0xF8,0x10,0x08,0x00,0x08,0x00,0x08,0xF0,0x08,0x11,0xF8,
0x11,0x08,0x11,0x00,0x11,0x00,0x11,0x00,0x15,0x02,0x19,0x02,0x10,0xFE,0x00,0x00
};
const unsigned char PROGMEM ri22[] = {
0x08,0x00,0x0B,0xF8,0x12,0x08,0x23,0xF8,0x4A,0x08,0x0B,0xF8,0x10,0x00,0x33,0xFC,
0x50,0x10,0x97,0xFE,0x10,0x10,0x12,0x10,0x11,0x10,0x10,0x10,0x10,0x50,0x10,0x20

};
const unsigned char PROGMEM ri23[] = {
0x02,0x00,0x02,0x00,0x07,0xF0,0x08,0x20,0x38,0x40,0x04,0x80,0x03,0x40,0x0C,0x80,
0x71,0xF8,0x02,0x08,0x0C,0x10,0x32,0x20,0x01,0x40,0x01,0x80,0x0E,0x00,0x70,0x00
};
const unsigned char PROGMEM ri24[] = {
0x00,0x00,0x03,0xF8,0x7A,0x08,0x4B,0xF8,0x4A,0x08,0x4B,0xF8,0x49,0x00,0x4B,0xFC,
0x4C,0x44,0x4A,0x44,0x7A,0xA4,0x4A,0x04,0x03,0xF4,0x00,0x04,0x00,0x28,0x00,0x10
};
const unsigned char PROGMEM ri25[] = {
0x02,0x00,0x02,0x00,0x02,0x00,0x03,0xFC,0x02,0x00,0x02,0x00,0x3F,0xF0,0x20,0x10,
0x20,0x10,0x20,0x10,0x3F,0xF0,0x00,0x00,0x24,0x88,0x22,0x44,0x42,0x44,0x80,0x04
};
const unsigned char PROGMEM ri26[] = {
0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x08,0x01,0x08,0x7D,0x90,0x05,0xA0,0x09,0x40,
0x09,0x40,0x11,0x20,0x11,0x10,0x21,0x08,0x41,0x06,0x81,0x00,0x05,0x00,0x02,0x00

};
const unsigned char PROGMEM ri31[] = {
0x01,0x00,0x01,0x00,0x02,0x80,0x04,0x40,0x08,0x20,0x12,0x10,0x21,0x08,0xC1,0x06,
0x00,0x00,0x1F,0xF0,0x00,0x10,0x00,0x20,0x00,0x20,0x00,0x40,0x00,0x80,0x01,0x00
};
const unsigned char PROGMEM ri32[] = {
0x00,0x00,0x3F,0xF8,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0xFF,0xFE,0x01,0x00,
0x02,0x80,0x02,0x80,0x04,0x40,0x04,0x40,0x08,0x20,0x10,0x10,0x20,0x08,0xC0,0x06
};
const unsigned char PROGMEM ri33[] = {
0x00,0x00,0x7F,0xFE,0x00,0x10,0x00,0x10,0x1F,0x10,0x11,0x10,0x11,0x10,0x11,0x10,
0x11,0x10,0x11,0x10,0x1F,0x10,0x11,0x10,0x00,0x10,0x00,0x10,0x00,0x50,0x00,0x20
};
const unsigned char PROGMEM ri34[] = {
0x10,0x40,0x24,0x44,0x42,0x48,0xFF,0x70,0x01,0x40,0x00,0x42,0x7E,0x42,0x42,0x3E,
0x42,0x00,0x7E,0x44,0x42,0x48,0x42,0x70,0x7E,0x40,0x42,0x42,0x4A,0x42,0x44,0x3E};
const unsigned char PROGMEM ri35[] = {
0x00,0x00,0x7F,0xFC,0x00,0x80,0x00,0x80,0x01,0x00,0x01,0x00,0x03,0x40,0x05,0x20,
0x09,0x10,0x11,0x08,0x21,0x04,0x41,0x04,0x81,0x00,0x01,0x00,0x01,0x00,0x01,0x00
};
const unsigned char PROGMEM ri36[] = {
0x10,0x40,0x24,0x44,0x42,0x48,0xFF,0x70,0x01,0x40,0x00,0x42,0x7E,0x42,0x42,0x3E,
0x42,0x00,0x7E,0x44,0x42,0x48,0x42,0x70,0x7E,0x40,0x42,0x42,0x4A,0x42,0x44,0x3E
};const unsigned char PROGMEM ri37[] = {
0x01,0x00,0x01,0x00,0x01,0x00,0x3F,0xF8,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,
0xFF,0xFE,0x02,0x00,0x02,0x00,0x04,0x00,0x08,0x20,0x10,0x10,0x3F,0xF8,0x00,0x08
};
const unsigned char PROGMEM ri38[] = {
0x10,0x80,0x10,0x40,0x13,0xFC,0x10,0x00,0xFD,0x08,0x10,0x90,0x17,0xFE,0x10,0x40,
0x18,0x40,0x37,0xFE,0xD0,0x88,0x11,0x08,0x10,0x90,0x10,0x60,0x51,0x98,0x26,0x04
};
const unsigned char PROGMEM ri39[] = {
0x00,0x00,0x7F,0xF8,0x00,0x10,0x00,0x20,0x00,0x40,0x01,0x80,0x01,0x00,0x01,0x00,
0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x05,0x00,0x02,0x00
};
const unsigned char PROGMEM ri310[] = {
0x08,0x80,0x08,0x80,0x08,0x80,0x11,0xFE,0x11,0x02,0x32,0x04,0x34,0x20,0x50,0x20,
0x91,0x28,0x11,0x24,0x12,0x24,0x12,0x22,0x14,0x22,0x10,0x20,0x10,0xA0,0x10,0x40
};
const unsigned char PROGMEM ri41[] = {
0x02,0x00,0x02,0x00,0xFF,0xFE,0x04,0x00,0x04,0x00,0x0F,0xF0,0x08,0x10,0x18,0x10,
0x2F,0xF0,0x48,0x10,0x88,0x10,0x0F,0xF0,0x08,0x10,0x08,0x10,0x08,0x50,0x08,0x20
};
const unsigned char PROGMEM ri42[] = {
0x08,0x20,0x08,0x20,0x08,0x20,0x10,0x20,0x10,0x20,0x30,0x20,0x37,0xFE,0x50,0x20,
0x90,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20
};
const unsigned char PROGMEM ri43[] = {
0x01,0x00,0x01,0x00,0x02,0x00,0x02,0x00,0x04,0x40,0x08,0x40,0x10,0x80,0x20,0x80,
0x41,0x00,0x02,0x00,0x04,0x20,0x08,0x10,0x10,0x08,0x3F,0xFC,0x10,0x04,0x00,0x00

};
const unsigned char PROGMEM ri44[] = {
0x00,0xA0,0x00,0x90,0xFC,0x80,0x05,0xFE,0x05,0x10,0x4B,0x10,0x2D,0xFC,0x29,0x10,
0x11,0x10,0x11,0xFC,0x29,0x10,0x25,0x10,0x45,0x10,0x81,0xFE,0x01,0x00,0x01,0x00
};
const unsigned char PROGMEM ri45[] = {
0x00,0x10,0x20,0x10,0x10,0x10,0x17,0xFE,0x00,0x10,0x00,0x10,0xF2,0x10,0x11,0x10,
0x11,0x10,0x10,0x10,0x10,0x10,0x10,0x50,0x10,0x20,0x28,0x00,0x47,0xFE,0x00,0x00
};
const unsigned char PROGMEM ri46[] = {
0x10,0x40,0x10,0x40,0x20,0x40,0x7E,0x7C,0x42,0x84,0x42,0x84,0x43,0x04,0x42,0x44,
0x7E,0x24,0x42,0x24,0x42,0x04,0x42,0x04,0x42,0x04,0x7E,0x04,0x42,0x28,0x00,0x10
};
const unsigned char PROGMEM ri47[] = {
0x00,0x00,0x20,0x00,0x11,0xF8,0x10,0x08,0x00,0x08,0x00,0x08,0xF0,0x08,0x11,0xF8,
0x11,0x08,0x11,0x00,0x11,0x00,0x11,0x00,0x15,0x02,0x19,0x02,0x10,0xFE,0x00,0x00
};
const unsigned char PROGMEM ri48[] = {
0x08,0x00,0x0B,0xF8,0x12,0x08,0x23,0xF8,0x4A,0x08,0x0B,0xF8,0x10,0x00,0x33,0xFC,
0x50,0x10,0x97,0xFE,0x10,0x10,0x12,0x10,0x11,0x10,0x10,0x10,0x10,0x50,0x10,0x20
};
const unsigned char PROGMEM ri49[] = {
0x01,0x00,0x11,0x00,0x11,0x00,0x1F,0xF8,0x21,0x00,0x41,0x00,0x01,0x00,0xFF,0xFE,
0x00,0x00,0x00,0x00,0x1F,0xF0,0x10,0x10,0x10,0x10,0x10,0x10,0x1F,0xF0,0x10,0x10
};
const unsigned char PROGMEM ri410[] = {
0x00,0x08,0x20,0x1C,0x11,0xE0,0x11,0x00,0x01,0x00,0x01,0x00,0xF1,0xFE,0x11,0x10,
0x11,0x10,0x11,0x30,0x11,0x18,0x15,0x14,0x19,0x12,0x12,0x10,0x02,0x10,0x04,0x10
};
const unsigned char PROGMEM ri411[] = {
0x04,0x40,0x0E,0x50,0x78,0x48,0x08,0x48,0x08,0x40,0xFF,0xFE,0x08,0x40,0x08,0x44,
0x0A,0x44,0x0C,0x48,0x18,0x30,0x68,0x22,0x08,0x52,0x08,0x8A,0x2B,0x06,0x10,0x02

};
const unsigned char PROGMEM ri412[] = {
0x09,0x00,0x08,0x80,0x08,0xBC,0x12,0x04,0x12,0x04,0x32,0x04,0x32,0x04,0x52,0x04,
0x92,0x04,0x12,0x04,0x12,0x04,0x12,0x04,0x12,0x04,0x12,0x04,0x12,0x14,0x12,0x08
};
const unsigned char PROGMEM ric1[] = {
0x00,0x20,0x00,0x20,0x7B,0xFE,0x48,0x20,0x49,0xFC,0x48,0x20,0x4B,0xFE,0x78,0x00,
0x49,0xFC,0x49,0x04,0x49,0xFC,0x49,0x04,0x79,0xFC,0x49,0x04,0x01,0x14,0x01,0x08
};
const unsigned char PROGMEM ric21[] = {
0x02,0x00,0x02,0x00,0x07,0xF0,0x08,0x20,0x38,0x40,0x04,0x80,0x03,0x40,0x0C,0x80,
0x71,0xF8,0x02,0x08,0x0C,0x10,0x32,0x20,0x01,0x40,0x01,0x80,0x0E,0x00,0x70,0x00
};
const unsigned char PROGMEM ric22[] = {
0x00,0x00,0x3F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFE,0x02,0x00,
0x04,0x00,0x04,0x00,0x08,0x40,0x10,0x20,0x20,0x10,0x7F,0xF8,0x20,0x08,0x00,0x08
};
const unsigned char PROGMEM ric3[] = {
0x00,0x00,0xFF,0xFE,0x01,0x00,0x01,0x00,0x01,0x00,0x7F,0xFC,0x41,0x04,0x41,0x04,
0x49,0x44,0x45,0x24,0x41,0x04,0x49,0x44,0x45,0x24,0x41,0x04,0x41,0x14,0x40,0x08
};
const unsigned char PROGMEM ric4[] = {
0x3F,0xF8,0x01,0x00,0x7F,0xFE,0x41,0x02,0x9D,0x74,0x01,0x00,0x1D,0x70,0x00,0x00,
0x3F,0xF8,0x00,0x08,0x00,0x08,0x1F,0xF8,0x00,0x08,0x00,0x08,0x3F,0xF8,0x00,0x08
};

#define INTERVAL_LCD             20             //定义OLED刷新时间间隔  
              //OLED刷新时间计时器
U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE);     //设置OLED型号  
//-------字体设置，大、中、小
#define setFont_L u8g.setFont(u8g_font_7x13)
#define setFont_M u8g.setFont(u8g_font_fixed_v0r)
#define setFont_S u8g.setFont(u8g_font_fixed_v0r)
#define setFont_SS u8g.setFont(u8g_font_fub25n)
#include <SoftwareSerial.h>
#include "edp.c"
#include <Wire.h>
#include<Arduino.h>
#include<math.h>

#define JDQ1 8
#define JDQ2 9
#define JDQ3 10
#define JDQ4 11
#define JDQ5 12
#define JDQ6 13
  
#define KEY  "YtbsO6deQ8DaxTUqe84HqZ6Imsw="    //APIkey
#define ID   "651156858"                         //设备ID
//#define PUSH_ID "680788"
#define PUSH_ID NULL


// 串口
#define _baudrate   9600
#define _rxpin      3
#define _txpin      2
#define WIFI_UART   mySerial
#define DBG_UART    Serial    //调试打印串口
int state=0;
int beforestate=0;
 //实际wifi连在2，3上
SoftwareSerial mySerial( _txpin, _rxpin ); 

edp_pkt *pkt;
/*两个函数，帮助你发送命令。
* doCmdOk 
* 发送命令至模块，从回复中获取期待的关键字
* keyword: 所期待的关键字
* 成功找到关键字返回true，否则返回false
*/
bool doCmdOk(String data, char *keyword)
{
  bool result = false;
  if (data != "")   //对于tcp连接命令，直接等待第二次回复
  {
    WIFI_UART.println(data);  //发送AT指令
    DBG_UART.print("SEND: ");
    DBG_UART.println(data);
    DBG_UART.println(WIFI_UART.readStringUntil('\n'));
  }
  if (data == "AT")   //检查模块存在
  {
    delay(2000);
  }
  else{
    while (!WIFI_UART.available());  // 等待模块回复
  }
 
  delay(200);
 
  if (WIFI_UART.find(keyword))   //返回值判断
  {
    DBG_UART.println("do cmd OK");
    result = true;
  }
  else
  {
    
    DBG_UART.println("do cmd ERROR");
    result = false;
  }
  while (WIFI_UART.available()) WIFI_UART.read();   //清空串口接收缓存
  delay(500); //指令时间间隔
  return result;
}

void setup()
{ 

 
  pinMode(JDQ2,INPUT);
  pinMode(JDQ3,OUTPUT);
  pinMode(JDQ4,OUTPUT);
  pinMode(JDQ5,OUTPUT);
  pinMode(JDQ6,OUTPUT);
  char buf[100] = {0};
  int tmp;
 pinMode(JDQ1,OUTPUT);  //用于连接EDP控制的发光二极管

  WIFI_UART.begin( _baudrate );
  DBG_UART.begin( _baudrate );
  WIFI_UART.setTimeout(3000);    //设置find超时时间
  delay(3000);
  DBG_UART.println("hello world!");

  delay(2000);
  while (!doCmdOk("AT", "OK"));
  while (!doCmdOk("AT+CWMODE=3", "OK"));            //工作模式
  while (!doCmdOk("AT+CWJAP=\"1024\",\"0987654321\"", "OK")); //wifi名称，wifi密码
  while (!doCmdOk("AT+CIPSTART=\"TCP\",\"183.230.40.39\",876", "CONNECT"));//CONNECT,Linked
  while (!doCmdOk("AT+CIPMODE=1", "OK"));           //透传模式
  while (!doCmdOk("AT+CIPSEND", ">"));              //开始发送
}

void loop()
{ 
  static int edp_connect = 0;
  bool trigger = false;
  edp_pkt rcv_pkt;
  unsigned char pkt_type;
  int i, tmp;
  char num[10];
  /* EDP 连接 */
  if (!edp_connect)
  {
    while (WIFI_UART.available()) WIFI_UART.read(); //清空串口接收缓存
    packetSend(packetConnect(ID, KEY));             //发送EPD连接包
    while (!WIFI_UART.available());                 //等待EDP连接应答
    if ((tmp = WIFI_UART.readBytes(rcv_pkt.data, sizeof(rcv_pkt.data))) > 0 )
    {
      rcvDebug(rcv_pkt.data, tmp);
      if (rcv_pkt.data[0] == 0x20 && rcv_pkt.data[2] == 0x00 && rcv_pkt.data[3] == 0x00)
      {
        edp_connect = 1;
        DBG_UART.println("EDP connected.");
      }
      else
        DBG_UART.println("EDP connect error.");
    }
    packetClear(&rcv_pkt);
    
  }

  while (WIFI_UART.available())
  { 
    readEdpPkt(&rcv_pkt);
    if (isEdpPkt(&rcv_pkt))//检查是否为edp模式的包，而且要注意离线命令与在线命令的格式不大一样，这个函数只能接受在线包
    { 
      pkt_type = rcv_pkt.data[0];
      
      
      DBG_UART.println(pkt_type);
      switch (pkt_type)
      {
        case CMDREQ:
          char edp_command[50];
          char edp_cmd_id[40];
          long id_len, cmd_len, rm_len;
          char datastr[20];
          char val[3];
          char val2[3];
          int value=1;
          memset(edp_command, 0, sizeof(edp_command));
          memset(edp_cmd_id, 0, sizeof(edp_cmd_id));
          edpCommandReqParse(&rcv_pkt, edp_cmd_id, edp_command, &rm_len, &id_len, &cmd_len);
          
     
          delay(10);
          DBG_UART.print("cmd: ");
          DBG_UART.println(edp_command);
          
     DBG_UART.print(*(edp_command+2));
 
       
        u8g.firstPage();
  do {
    setFont_S;
    u8g.setPrintPos(10, 8);
    u8g.print(edp_command);
   
  } while (u8g.nextPage());
          //（这里可以采用onenet应用模块设计开关来进行调试）
          //正常使用时需要调用命令下发api其中这个值需要你自己输入

          //数据处理与应用中EDP命令内容对应
          //本例中格式为  datastream:[1/0]
          sscanf(edp_command, "%[^:]:%s", datastr, val);
        
            DBG_UART.println(atoi(edp_command));
          if (atoi(edp_command)==5){
          digitalWrite(JDQ6, HIGH);
               u8g.firstPage();
           do {
    setFont_M;
    u8g.drawBitmapP(54,30,2,16, ric1);}  
    while (u8g.nextPage());
         }   
           if (atoi(edp_command)==6){
          digitalWrite(JDQ5, HIGH);
                    u8g.firstPage();
           do {
    setFont_M;
    u8g.drawBitmapP(40,30,2,16, ric21);
    u8g.drawBitmapP(60,30,2,16, ric22);}  
    while (u8g.nextPage());
          }   
           if (atoi(edp_command)==7){
          analogWrite(JDQ4,random(120)+135);
                       u8g.firstPage();
           do {
    setFont_M;
    u8g.drawBitmapP(54,30,2,16, ric3);}  
    while (u8g.nextPage());
      delay(100000);
      analogWrite(JDQ4,0);
          }   
         
           if (atoi(edp_command)==8){
     analogWrite(JDQ3,random(120)+135);
                        u8g.firstPage();
           do {
    setFont_M;
    u8g.drawBitmapP(54,30,2,16, ric4);}  
    while (u8g.nextPage());
       delay(100000);
      analogWrite(JDQ3,0);
          }   
         if(atoi(edp_command)==1){
           u8g.firstPage();
           do {
    setFont_M;
    u8g.drawBitmapP(10,10,2,16, ri11);
    u8g.drawBitmapP(30,10,2,16, ri12);
   u8g.drawBitmapP(50,10,2,16, ri13);
    u8g.drawBitmapP(70,10,2,16, ri14);
    u8g.drawBitmapP(90,10,2,16, ri15);
    u8g.drawBitmapP(10,30,2,16, ri16);
  u8g.drawBitmapP(30,30,2,16, ri17);}  
  while (u8g.nextPage());}
      if(atoi(edp_command)==11){
           u8g.firstPage();
           do {
    setFont_M;
    u8g.drawBitmapP(10,10,2,16, ri21);
    u8g.drawBitmapP(30,10,2,16, ri22);
   u8g.drawBitmapP(50,10,2,16, ri23);
    u8g.drawBitmapP(70,10,2,16, ri24);
    u8g.drawBitmapP(90,10,2,16, ri25);
    u8g.drawBitmapP(10,30,2,16, ri26);
 }  
  while (u8g.nextPage());}
            if(atoi(edp_command)==21){
           u8g.firstPage();
           do {
    setFont_M;
    u8g.drawBitmapP(10,10,2,16, ri31);
    u8g.drawBitmapP(30,10,2,16, ri32);
   u8g.drawBitmapP(50,10,2,16, ri33);
    u8g.drawBitmapP(70,10,2,16, ri34);
    u8g.drawBitmapP(90,10,2,16, ri35);
    u8g.drawBitmapP(10,30,2,16, ri36);
    u8g.drawBitmapP(30,30,2,16, ri37);
    u8g.drawBitmapP(50,30,2,16, ri38);
    u8g.drawBitmapP(70,30,2,16, ri39);
    u8g.drawBitmapP(90,30,2,16, ri310);
 }  
  while (u8g.nextPage());}
            if(atoi(edp_command)==31){
           u8g.firstPage();
           do {
    setFont_M;
    u8g.drawBitmapP(10,10,2,16, ri41);
    u8g.drawBitmapP(30,10,2,16, ri42);
   u8g.drawBitmapP(50,10,2,16, ri43);
    u8g.drawBitmapP(70,10,2,16, ri44);
    u8g.drawBitmapP(90,10,2,16, ri45);
    u8g.drawBitmapP(110,10,2,16, ri46);
    u8g.drawBitmapP(10,30,2,16, ri47);
    u8g.drawBitmapP(30,30,2,16, ri48);
    u8g.drawBitmapP(50,30,2,16, ri49);
    u8g.drawBitmapP(70,30,2,16, ri410);
    u8g.drawBitmapP(90,30,2,16, ri411);
 }  
  while (u8g.nextPage());}

          packetSend(packetDataSaveTrans(NULL, datastr, val)); //将新数据值上传至数据流
          break;
        default:
          DBG_UART.print("unknown type: ");
          DBG_UART.println(pkt_type, HEX);
          break;
      }
    }
    //delay(4);
  }
  if (rcv_pkt.len > 0)
    packetClear(&rcv_pkt);
  delay(150);
}

/*
* readEdpPkt
* 从串口缓存中读数据到接收缓存
*/
bool readEdpPkt(edp_pkt *p)
{
  int tmp;
  if ((tmp = WIFI_UART.readBytes(p->data + p->len, sizeof(p->data))) > 0 )
  {
    rcvDebug(p->data + p->len, tmp);
    p->len += tmp;
  }
  return true;
}

/*
* packetSend
* 将待发数据发送至串口，并释放到动态分配的内存
*/
void packetSend(edp_pkt* pkt)
{
  if (pkt != NULL)
  {
    WIFI_UART.write(pkt->data, pkt->len);    //串口发送
    WIFI_UART.flush();
    free(pkt);              //回收内存
  }
}

void rcvDebug(unsigned char *rcv, int len)
{
  int i;
  DBG_UART.print("rcv len: ");
  DBG_UART.println(len, DEC);
  for (i = 0; i < len; i++)
  {
    DBG_UART.print(rcv[i], HEX);
    DBG_UART.print("");
  }
  DBG_UART.println("");
}
